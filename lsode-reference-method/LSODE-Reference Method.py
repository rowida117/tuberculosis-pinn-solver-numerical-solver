# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

import numpy as np
import math
import matplotlib.pyplot as plt
import pandas as pd
import time
import timeit

def generate_reference_solution():
  data = {
    'Time': [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5,
             5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5,
             10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5,
             15, 15.5, 16, 16.5, 17, 17.5, 18, 18.5, 19, 19.5, 20],
    'S': [198.019802, 198.01636, 198.0044105, 197.9807888, 197.941096, 197.8791619, 197.7864062,
          197.6509083, 197.4561469, 197.1792823, 196.788907, 196.242146, 195.4809926, 194.4280278,
          192.9818642, 191.0132649, 188.3638255, 184.8503061, 180.2790401, 174.4745976, 167.3241127,
          158.8306833, 149.1581485, 138.6417623, 127.7473277, 116.9851168, 106.8113835, 97.55661839,
          89.4006011, 82.3886953, 76.4698496, 71.53710065, 67.45989047, 64.10546112, 61.35079061,
          59.08791325, 57.22518947, 55.68654817, 54.40969968, 53.34408205, 52.44892442],
    'E': [1, 0.995453886, 0.998307619, 1.011275379, 1.038131156, 1.084170975, 1.15676163,
          1.266142624, 1.426512702, 1.657514933, 1.986187757, 2.449492843, 3.097534376, 3.997370901,
          5.237177312, 6.930014255, 9.215708622, 12.25830072, 16.23535085, 21.3153444, 27.62135491,
          35.18528663, 43.9060817, 53.53263444, 63.68777838, 73.93210197, 83.84462755, 93.08931092,
          101.4476175, 108.8171771, 115.1887637, 120.6162937, 125.1895235, 129.013429, 132.194589,
          134.8332365, 137.0193388, 138.8311262, 140.3352036, 141.5874335, 142.6341197],
    'I': [0, 0.002932487, 0.006952912, 0.012494922, 0.020159812, 0.03078921, 0.045550691,
          0.066062026, 0.094557518, 0.13411138, 0.188923544, 0.264674761, 0.368949686, 0.511677947,
          0.705495941, 0.965822489, 1.310263879, 1.756817172, 2.320173014, 3.005728156, 3.801768586,
          4.672101826, 5.553417592, 6.362019849, 7.01086558, 7.43172083, 7.59259288, 7.502447628,
          7.203085503, 6.753859262, 6.216570095, 5.645013685, 5.080112292, 4.549320893, 4.06847652,
          3.644563098, 3.278459759, 2.96723488, 2.705859211, 2.488395342, 2.308756903],
    'L': [0, 2.44167E-06, 1.05807E-05, 2.60559E-05, 5.12122E-05, 8.94006E-05, 0.000145336,
          0.000225625, 0.000339478, 0.000499701, 0.000724, 0.001036699, 0.001470977, 0.002071606,
          0.00289812, 0.004028061, 0.005559515, 0.007611379, 0.010318928, 0.01382151, 0.018239415,
          0.023639651, 0.029995968, 0.03715619, 0.044833952, 0.052636292, 0.06012367, 0.06688369,
          0.072592947, 0.077051482, 0.080186375, 0.082032748, 0.082703726, 0.08235916, 0.081178954,
          0.07934335, 0.077020157, 0.074357518, 0.07148106, 0.068493751, 0.065477386]
}

  # Create DataFrame
  df = pd.DataFrame(data)
  return df

def GetReferenceValues():
  df = generate_reference_solution()
  time_true = df['Time'].values.astype(np.float32)
  S_true = df['S'].values
  E_true = df['E'].values
  I_true = df['I'].values
  L_true = df['L'].values
  return S_true, E_true, I_true, L_true
def CalculateMSE(S, E, I, L):
  S_true, E_true, I_true, L_true = GetReferenceValues()
  S_MSE = np.mean((S_true - S)**2)
  E_MSE = np.mean((E_true - E)**2)
  I_MSE = np.mean((I_true - I)**2)
  L_MSE = np.mean((L_true - L)**2)
  return S_MSE, E_MSE, I_MSE, L_MSE

def CalculateMSEDifferentTimes(S, E, I, L, t_sim):
    df = generate_reference_solution()
    t_ref = df['Time'].values.astype(np.float32)
    S_true = df['S'].values
    E_true = df['E'].values
    I_true = df['I'].values
    L_true = df['L'].values

    # For each reference time, find nearest simulation time
    indices = np.searchsorted(t_sim, t_ref, side='left')
    indices = np.clip(indices, 0, len(t_sim)-1)

    # Handle edge cases - check if left or right neighbor is closer
    for i in range(len(indices)):
        if indices[i] > 0:
            left_dist = abs(t_ref[i] - t_sim[indices[i]-1])
            right_dist = abs(t_ref[i] - t_sim[indices[i]])
            if left_dist < right_dist:
                indices[i] -= 1

    S_MSE = np.mean((S_true - S[indices])**2)
    E_MSE = np.mean((E_true - E[indices])**2)
    I_MSE = np.mean((I_true - I[indices])**2)
    L_MSE = np.mean((L_true - L[indices])**2)

    return S_MSE, E_MSE, I_MSE, L_MSE